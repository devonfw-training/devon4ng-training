<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Unit Testing</title>
    <link rel="icon" href="../common/img/favicon.ico">

    <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <link rel="stylesheet" href="../node_modules/reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../node_modules/reveal.js/css/theme/white.css">
    <link rel="stylesheet" href="../common/css/common.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../common/css/github-gist.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? '../node_modules/reveal.js/css/print/pdf.css' : '../node_modules/reveal.js/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<section class="devon-link">
    <a href="http://devonfw.github.io" target="_blank"><img height="30px" src="../common/img/devon_logo_blue.png"></a>
</section>
<section class="angular-link">
    <a href="http://angular.io" target="_blank"><img height="50px" src="../common/img/angular.svg"></a>
</section>    
<div class="devon reveal">
    <div class="slides">
        <section>
            <h1>Testing</h1>
			<img class="reset" src="img/angular-2-testing.jpg">
		</section>	
        <section>
			<h2>Tools</h2>
			<ul>
				<li><span class="highlight">Jasmine</span> - BDD testing framework</li>
				<li><span class="highlight">Angular Testing Utilities</span> - create test environment for Angular application code under test</li>
				<li><span class="highlight">Karma</span> - test runner</li>
				<li><span class="highlight">Cypress</span> - end-to-end testing framework without the need of Selenium (see <a href="https://devonfw.com/website/pages/docs/guide-cypress.asciidoc.html#guide-cypress.asciidoc">devonfw</a>)</li>
			</ul>
			<p><small><a target="_blank" href="https://angular.io/docs/ts/latest/guide/testing.html">https://angular.io/docs/ts/latest/guide/testing.html</a></small><p>		
		</section>
		<section>
			<h2>Jasmine syntax</h2>
			<pre><code class="hljs typescript">// test suite
describe('HelloService', () => {

  // spec
  it('should say hello', () => {
      let sut = new HelloService();

      let actual = sut.speak();

      expect(actual).toBe('hello');
  });

});</code></pre>
            <p>This test is read: <blockquote>HelloService should say hello</blockquote></p>
		</section>
		<section>
            <h3>Testing conventions</h3>
            <p>HelloService spec file is placed in the <span class="highlight">same folder</span>.</p>
            <ul>
                <li>hello.service.ts</li>
                <li>hello.service.spec.ts</li>
            </ul>
        </section>
        <section>
            <h3>Why is that?</h3>
            <ul>
                <li>Such tests are easy to <span class="highlight">find</span></li>
                <li>You see at a glance if a part of our application <span class="highlight">lacks tests</span>.</li>
                <li>Nearby tests can reveal <span class="highlight">how a part works</span> in context.</li>
                <li>When you move the source (inevitable), you <span class="highlight">remember to move the test</span>.</li>
                <li>When you rename the source file (inevitable), you <span class="highlight">remember to rename</span> the test file.</li>
            </ul>
            <div class="quote-source">
                <a href="https://angular.io/docs/ts/latest/guide/testing.html#!#faq" target="_blank">Angular Docs</a>
            </div>
        </section>
        <section>
            <p>
                Remember how the build differs to Java or .Net. No test code is build for production by <span class="highlight">file pattern</span>.
                <blockquote>*.spec.ts</blockquote>
            </p>
        </section>
        <section>
            <h3>Configuration</h3>
            <p>Karma is configured in</p>
            <pre><code>karma.conf.js</code></pre>
            <p>Start karma with</p>
            <pre><code>karma start</code></pre>
            <p>Angular-CLI abstracts from karma and lets you start with</p>
            <pre><code>ng test</code></pre>
        </section>
        <section>
            <h3>Patterns</h3>
        </section>
        <section>
            <p>AAA / <span class="highlight">GWT</span> is always a good idea!</p>
            <pre><code class="typescript" data-trim>
describe('TestService', () => {

  it('should return blue if name is otto', () => {
    const sut = new TestService();
    sut.name = 'otto';

    const actual = sut.spell();

    expect(actual).toBe('blue');
  });

});
            </code></pre>
        </section>
        <section>
            <p>When testing more than one function use <span class="highlight">nested describes</span>.</p>
            <pre><code class="typescript" data-trim>
describe('TestService', () => {

    describe('spell', () => {

    });

    describe('dance', () => {

    });

});
            </code></pre>
        </section>
        <section>
            <p>Create const helper and variables outside of specs to keep <span class="highlight">specs short and readable</span>.</p>
        </section>
        <section>
            <p>Initialize inside <code class="typescript highlight">beforeEach()</code> function</p>
                <pre><code data-trim class="typescript">
describe('TestService', () => {

  let sut: TestService;

  beforeEach(() => {
    sut = new TestService();
  });

});
            </code></pre>
        </section>
        <section>
            <h3>Expecting behavior</h3>
            <p>expect value is 1 <pre><code class="typescript">expect(value).toEqual(1);</code></pre></p>
            <p>negatin with not <pre><code class="typescript">expect(value).not.toEqual(1);</code></pre></p>
            <p>expect value greater <pre><code class="typescript">expect(value).toBeGreaterThan(0);</code></pre></p>
            <p>truthy / falsy<pre><code class="typescript">expect(value).toBeTruthy(); expect(value).toBeFalsy();</code></pre></p>
            <div class="quote-source">
                <a href="https://jasmine.github.io/pages/docs_home.html" target="_blank">see Jasmine Docs</a>
            </div>
        </section>
        <section>
            <h3>Mocks, Stubs, Fakes, Spies</h3>
            <p>Jasmine comes pre-equipped with mocking ability.</p>
            <p>spy on existing function</p>
            <pre><code class="typescript">spyOn(obj, 'methodName');</code></pre>
            <p>spy on new function</p>
            <pre><code class="typescript">jasmine.createSpy('methodName').and.returnValue(4711)</code></pre>
            <p>create object with spies</p>
            <pre><code data-trim class="typescript">
jasmine.createSpyObj&lt;ServiceName&gt;(['func1', 'func2']);
jasmine.createSpyObj&lt;ServiceName&gt;({
    func1: true,
    func2: 'otto'
});
            </code></pre>
        </section>
        <section>
                <p>Assert method has been called <pre><code class="typescript">expect(obj.methodName).toHaveBeenCalled()</code></pre></p>
                <p>Assert method has been called with argument <pre><code class="typescript">expect(obj.methodName).toHaveBeenCalledWith(args)</code></pre></p>            
                <p>Assert method has been called amount of times <pre><code class="typescript">expect(obj.methodName).toHaveBeenCalledTimes(count);</code></pre></p>                        
        </section>
        <section>
            <section>
                <h3>Isolated Tests</h3>
                <p>Isolated unit tests examine an instance of a class all by itself <span class="highlight">without any dependence on Angular</span> or any injected values.</p>
                <div class="quote-source">
                    <a href="https://angular.io/docs/ts/latest/guide/testing.html#!#isolated-v-testing-utilities" target="_blank">Angular Docs</a>
                </div>
            </section>
            <section>
                <h3>When to use isolated tests?</h3>
                <ul>
                    <li>Services</li>
                    <li>Pipes</li>
                    <li>Components (if possible)</li>
                    <li>Directives (if possible)</li>
                </ul>
            </section>
            <section>
                <h3>HelloService Example</h3>
                <p>Given are three files.</p>
                <ul>
                   <li>hello.service.spec.ts</li> 
                   <li>hello.service.ts</li> 
                   <li>speaker.ts</li> 
                </ul>
            </section>
            <section>
                <h3>Speaker</h3>
                <pre><code data-trim class="max-height-unset typescript">
export class Speaker {

  speak(val: string): void {
    // highly sophisticated operation...
    console.log('speaker:', val);
  }

}
</code></pre>
            </section>
            <section>
                <h3>HelloService</h3>
                <pre><code class="max-height-unset typescript">import { Injectable } from '@angular/core';
import { Speaker } from './speaker';

@Injectable()
export class HelloService {
    private speech: string[] = [];

    constructor(private speaker: Speaker) { }

    say(line: string): void {
        this.speaker.speak(line);
        this.speech.push(line);
    }

    getSpeech(): string {
        return this.speech.join('\n');
    }
}
</code></pre>
            </section>
            <section>
                <h3>HelloService spec</h3>
                <pre><code data-trim class="max-height-unset javascript">
describe('HelloService', () => {
  let speakerFake: Speaker;
  let sut: HelloService;
        
  beforeEach(() => {
    speakerFake = jasmine.createSpyObj&lt;Speaker&gt;(['speak']);
    sut = new HelloService(speakerFake);
  });

  describe('say', () => {
    it('should call Speaker', () => {
      const speechLine = 'This is Sparta!';

      sut.say(speechLine);

      expect(speakerFake.speak).toHaveBeenCalledWith(speechLine);
    });
  });
});</code></pre>
            </section>
        </section>
        <section>
            <section>
                <h3>Angular testing utilities</h3>
                <p>Let you test components including their <span class="highlight">interaction with Angular</span>.</p>
            </section>
            <section>
                <h3>TestBed Testing API</h3>
            </section>
            <section>
                <p><strong>TestBed</strong> creates an Angular module.</p>
                <p>Its purpose is to create a <span class="highlight">controlled test setup</span>.</p>
                <pre><code data-trim class="typescript">
import { TestBed } from '@angular/core/testing';
import { HelloComponent } from './hello.component';

describe('HelloComponent', () => {

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ HelloComponent ]
    });
  });

})
                </code></pre>
            </section>
            <section>
                <code>ComponentFixture</code>
                <p>Fixture for <span class="highlight">debugging and testing</span> a component.</p>
                <pre><code data-trim data-noescape class="typescript">
TestBed.configureTestingModule({
  declarations: [ HelloComponent ],
});

const fixture = <mark>TestBed.createComponent(HelloComponent);</mark>
                </code></pre>                    
            </section>
            <section>
                <p><code>ComponentFixture.componentInstance</code> provides <span class="highlight">access to the component</span></p>                    
                <pre><code data-trim data-noescape class="typescript max-height-unset">
import { TestBed } from '@angular/core/testing';
import { HelloComponent } from './hello.component';
                        
describe('HelloComponent', () => {

  let component: HelloComponent;

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ HelloComponent ]
    });
    const fixture = TestBed.createComponent(HelloComponent);
    <mark>component = fixture.componentInstance;</mark>
  });

});
                </code></pre>
            </section>
            <section>
                <p><code>ComponentFixture.debugElement</code> provides <span class="highlight">access to the components HTML tree</span></p>
                <pre><code data-trim data-noescape class="typescript max-height-unset">
import { DebugElement } from '@angular/core';
import { TestBed } from '@angular/core/testing';
import { HelloComponent } from './hello.component';
                        
describe('HelloComponent', () => {

    let debugElement: DebugElement;

    beforeEach(() => {
      TestBed.configureTestingModule({
          declarations: [ HelloComponent ]
      });
      const fixture = TestBed.createComponent(HelloComponent);
      <mark>debugElement = fixture.debugElement;</mark>
    });

});
                </code></pre>                        
            </section>
            <section>
                <p>... which <span class="highlight">can be queried</span> - e.g. by css selector</p>
                <pre><code data-trim data-noescape class="typescript max-height-unset">
import { By } from '@angular/platform-browser';
                        
const debugElement = fixture.debugElement.query(By.css('h1'));
                </code></pre>                
            </section>
            <section>
                <p>DebugElement.nativeElement provides <span class="highlight">access to <code>HTMLElement</code></span> (native browser API)</p>                    
                <pre><code data-trim data-noescape class="typescript">
const debugElement = fixture.debugElement.query(By.css('h1'));
const nativeElement = debugElement.nativeElement;

console.log(nativeElement.textContent);
                </code></pre>
            </section>
            <section>
                <p>
                    For a component to adjust its bindings during a test,
                    you need to call <code>detectChanges()</code> to notify Angular that
                    <span class="highlight">change detection</span> needs to be run.
                </p>
            </section>
            <section>
                <p>... and there is an API on <strong>TestFixture</strong></p>                    
                <pre class="width-100-percent"><code data-trim class="typescript">
it('should display a different test title', () => {
  const h1Element = fixture.debugElement.query(By.css('h1'));    

  fixture.componentInstance.title = 'Test Title';
  fixture.detectChanges();

  expect(h1Element.nativeElement.textContent).toContain('Test Title');
});
                </code></pre>
            </section>
            <section>
                <h3>Testing components with dependencies</h3>
                <p><code>TestBed.configureTestingModule({})</code> has like <code>@NgModule({})</code> a property called <span class="highlight">providers</span>.</p>
            </section>
            <section>
                <p>For a component to be able to be build you need to <span class="highlight">register all dependencies</span>.</p>
                <pre class="width-100-percent"><code data-trim class="typescript">
// 'real' dependency
TestBed.configureTestingModule({
  providers: [ HelloService ] 
});
                </code></pre>
                <pre class="width-100-percent"><code data-trim class="typescript">
// 'fake' dependency
TestBed.configureTestingModule({
  providers: [ { provide: HelloService, useValue: helloServiceFake } ] 
});
                </code></pre>
            </section>
            <section>
                <h3>Real vs Fake</h3>
                <p>Both are possible. A real dependency can even be stubbed after creation.</p>
            </section>
            <section>
                <p>To stub the real dependency you need to retrieve the runtime instance via</p>
                <pre><code class="typescript">fixture.debugElement.injector.get(Speaker)</code></pre>
                <p>or</p>
                <pre><code class="typescript">TestBed.inject(Speaker)</code></pre>
                <span class="highlight">Using the components fixture should be preferred</span> since it is less error prone.
            </section>
            <section>
                <h3>Testing asynchronous functionality</h3>
            </section>
            <section>
                <p>waitForAsync makes the test wait until all asynchronous operations are completed.</p>
                <pre><code data-noescape data-trim class="typescript">
import { waitForAsync } from '@angular/core/testing';

it('should display hello', <mark>waitForAsync(</mark>() => {
  let sut = new TestService();

  sut.doSomething().then(result => {
    expect(result).toBe('hello');
  });
}));</code></pre>
            </section>
            <section>
                <p>
                    <code>fakeAsync</code> differentiates between
                    <strong>micro</strong> and <strong>macrotasks</strong>
                    (tasks and jobs).
                </p>
            </section>
            <section>
                <code>flushMicrotasks</code>
                <p>Flush any pending microtasks.</p>
                <pre class="width-100-percent"><code data-noescape data-trim class="typescript">
import { fakeAsync, flushMicrotasks } from '@angular/core/testing';

it('should display hello', fakeAsync(() => {
    let flag = false;
    Promise.resolve().then(() => { flag = true; });

    expect(flag).toBeFalsy();

    <mark>flushMicrotasks();</mark>

    expect(flag).toBeTruthy();
}));
                </code></pre>
            </section>
            <section>
                <p>... macrotasks remain in the queue and are <strong>not executed</strong></p>
                <pre class="width-100-percent"><code data-noescape data-trim class="typescript">
import { fakeAsync, flushMicrotasks } from '@angular/core/testing';

it('should display hello', fakeAsync(() => {
    let flag = false;
    setTimeout(() => { flag = true; });

    expect(flag).toBeFalsy();

    flushMicrotasks();

    expect(flag).toBeTruthy(); <mark>// Error!</mark>
}));
                </code></pre>
            </section>
            <section>
                <code>tick</code>
                <p>Simulates the asynchronous passage of time for the timers in the fakeAsync zone.</p>
                <p>The microtasks queue is drained at the very start of this function and after any timer callback has been executed.</p>
            </section>
            <section>
                <pre class="width-100-percent"><code data-noescape data-trim class="typescript">
import { fakeAsync, tick } from '@angular/core/testing';

it('should display hello', fakeAsync(() => {
    let flag = false;
    setTimeout(() => { flag = true; });

    expect(flag).toBeFalsy();

    <mark>tick();</mark>

    expect(flag).toBeTruthy();
}));
                </code></pre>
            </section>
            <section>
                <pre class="width-100-percent"><code data-noescape data-trim class="typescript">
import { fakeAsync, tick } from '@angular/core/testing';

it('should display hello', fakeAsync(() => {
    let flag = false;
    setTimeout(() => { flag = true; }, <mark>100</mark>);

    <mark>tick(50);</mark>    

    expect(flag).toBeFalsy();

    <mark>tick(50);</mark>

    expect(flag).toBeTruthy();
}));
                </code></pre>
            </section>
            <section>
                <h3>Emitting events</h3>
                <p><code>DebugElement.triggerEventHandler('click', null)</code> emits a click event.</p>
                <p>TestBed can be configured</p> 
                <pre class="width-100-percent"><code data-trim data-noescape class="typescript">
TestBed.configureTestingModule({
  ...
  schemas: [ NO_ERRORS_SCHEMA ]
})
                </code></pre>
                <p>which allows for <span class="highlight">easy EventEmitter (@Output) tests</span>.</p>
                <pre class="width-100-percent"><code class="html">&lt;my-component (somethingChanged)="method($event)"&gt;&lt;/my-component&gt;</code></pre>
                <pre class="width-100-percent"><code class="typescript">debugElement.triggerEventHandler('somethingChanged', whatHasChanged)</code></pre>
            </section>
            <section>
                <p>HttpClientTestingModule lets all calls made by HttpClient hit a fake backend.</p>                
                <pre class="width-100-percent"><code data-trim class="typescript">
import { HttpClientTestingModule } from '@angular/common/http/testing';

beforeEach(() => {
  TestBed.configureTestingModule({
    ...,
    imports: [
      HttpClientTestingModule,
    ],
  })
});
                </code></pre>
            </section>
            <section>
                <pre class="width-100-percent"><code class="max-height-unset typescript" data-trim>
it('expects a GET request', inject(
    [BookService, HttpTestingController],
    (sut: BookService, httpMock: HttpTestingController) => {
  
  sut.getBooks()
     .subscribe(books => expect(books.length).toBe(1));   

  const req = httpMock.expectOne('/data');
    
  expect(req.request.method).toEqual('GET');
    
  req.flush([{ id: 1, name: 'Book of Ra', author: 'Mr Gambler' }]);
    
  httpMock.verify();
}));
                </code></pre>
            </section>
        </section>
    </div>
</div>

<script src="../node_modules/reveal.js/js/reveal.js"></script>
<script src="../common/reveal-config.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({ ...revealConfig });
</script>
</body>
</html>
