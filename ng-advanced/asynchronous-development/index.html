<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Asynchronous Development</title>

    <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <link rel="icon" href="./img/favicon.ico">
    <link rel="stylesheet" href="./reveal.js/css/reveal.css">
    <link rel="stylesheet" href="./reveal.js/css/theme/simple.css">
    <link rel="stylesheet" href="./css/common.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="./css/github-gist.css">
    <link rel="stylesheet" href="css/js-engine.css">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section class="fullscreen" data-background-size="80rem" data-background-position="0% 100%"
                 data-background-image="./img/Fixed_Shape_5_CapgeminiBlue_RGB.svg">
            <div class="header-bottom-left">
                <h1 class="cap-white">Asynchronous development with Angular</h1>
                <p class="cap-white">Philip Schm√∂kel, Bernd Olleck</p>
            </div>
        </section>
        <section>
            <section class="fullscreen">
                <h2>What do you know about the JavaScript Eventloop?</h2>
                <div style="display:flex; justify-content: center;padding-top: 4rem">
                    <img class="event-loop-scribble" src="./img/event-loop.svg" alt="JavaScript Event Loop">
                </div>
                <ul>
                    <li>You know about <span class="cap-blue">Tasks</span> and <span class="cap-blue">Jobs</span>/<span
                            class="cap-blue">Microtasks</span>?
                    </li>
                </ul>
                <aside class="notes">
                    Some useful links:
                    <UL>
                        <LI>
                            https://javascript.info/event-loop
                        </LI>
                        <LI>
                            https://javascript.info/microtask-queue
                        </LI>
                    </UL>
                </aside>
            </section>
            <section>
                <!-- taken from the foundation slides of "promises-to-observables" -->
                <div id="js-engine">
                    <p>JavaScript Engine (simplified)</p>
                    <pre><code style="border: none;" data-trim class="javascript">
    var bar = function () {
            console.log('bar...');
        },
        foo = function () {
            setTimeout(bar, 5000);
            console.log('foo...');
        };
    foo();
                        </code></pre>
                    <div id="js-engine-core">
                        <div id="call-stack">
                            <p>Call Stack</p>
                        </div>
                        <div id="event-table">
                            <p>Event Table</p>
                        </div>
                        <div id="event-queue">
                            <p>Event Queue</p>
                        </div>
                        <div id="console">
                            <p>Console</p>
                            <!--<pre class="code-element"><code data-trim class="javascript">"I'm second!"</code></pre>-->
                        </div>
                    </div>
                    <div class="navigate-left enabled"></div>
                </div>
                <div>
                    <a href="javascript:jsEngineSteps.backward()">&lt;&lt;</a>&nbsp;
                    <a href="javascript:jsEngineSteps.forward()">&gt;&gt;</a>
                </div>
            </section>
        </section>
        <section>
            <p>Each thread has its own event loop.</p>
            <ul>
                <li>UI per origin</li>
                <li>web workers</li>
            </ul>
        </section>
        <section>
            <section>
                <p>Explain the relation between <strong class="cap-blue">Event Loop</strong>, <strong
                        class="cap-blue">Tasks</strong> and <strong class="cap-blue">Microtasks</strong></p>
                <aside class="notes">
                    Discuss
                    <UL>
                        <LI>
                            Samples of Tasks / Macrotasks
                            <UL>
                                <LI>User events</LI>
                                <LI>Executing the code loaded with a &lt;script src=&quot;...&quot;&gt; tag</LI>
                                <LI>Timeouts which are ready</LI>
                            </UL>
                            Samples of Microtasks
                            <UL>
                                <LI>Promise-Result/Error</LI>
                                <LI>queueMicrotask(...)</LI>
                            </UL>
                        </LI>
                        <LI>Task synonymous with Macrotask, Job with Microtask</LI>
                        <LI>Rendering happens between tasks, not while a task is running</LI>
                        <LI>The microtaskqueue is emptied after the macrotask and before rendering</LI>
                        <LI>How do we create a macrotask / microtask</LI>
                        <LI>How do we display a progress dialog if we do not use Web Workers?</LI>
                        <LI>How do we do something after our current code is finished and the result rendered?</LI>
                    </UL>
                </aside>
            </section>
            <section>
                <p>Explain the relation between <strong class="cap-blue">Event Loop</strong>, <strong
                        class="cap-blue">Tasks</strong> and <strong class="cap-blue">Microtasks</strong></p>
                <pre><code class="javascript" data-trim data-line-numbers="">
                    eventLoop() {
                      while (!endOfWorld) {
                        task = getNextMacrotaskOrNullIfEmpty();
                        if (task) {
                          task.execute();
                        }
                        while (task = getNextMicrotaskOrNullIfEmpty()) {
                          task.execute();
                        }
                        render();
                      }
                    }
                </code></pre>
                <aside class="notes">
                    Discuss
                    <UL>
                        <LI>
                            Samples of Tasks / Macrotasks
                            <UL>
                                <LI>User events</LI>
                                <LI>Executing the code loaded with a &lt;script src=&quot;...&quot;&gt; tag</LI>
                                <LI>Timeouts which are ready</LI>
                            </UL>
                            Samples of Microtasks
                            <UL>
                                <LI>Promise-Result/Error</LI>
                                <LI>queueMicrotask(...)</LI>
                            </UL>
                        </LI>
                        <LI>Task synonymous with Macrotask, Job with Microtask</LI>
                        <LI>Rendering happens between tasks, not while a task is running</LI>
                        <LI>The microtaskqueue is emptied after the macrotask and before rendering</LI>
                        <LI>How do we create a macrotask / microtask</LI>
                        <LI>How do we display a progress dialog if we do not use Web Workers?</LI>
                        <LI>How do we do something after our current code is finished and the result rendered?</LI>
                    </UL>
                </aside>
            </section>
            <section>
                <p>Why does this progress bar not work?</p>
                <pre><code class="javascript" data-trim data-line-numbers="">
                      console.log('starting work');
                      updateProgressSync(0);
                      for( let i=1; i<=10; i++) {
                          busyWaitMs(1000);
                          let percent = i/10*100;
                          updateProgressSync(percent);
                      }
                      console.log('finished with work');
                </code></pre>
                <div>
                    <button id="buttonSyncProgressBar">Do A Lot Of Work</button>
                    Progress: <span id="syncProgressBarValue">0%</span>
                    <progress id="syncProgressBar" max="100" value="0"></progress>
                </div>
                <script>
                    function busyWaitMs(waitMs) {
                        if (!waitMs) {
                            waitMs = 100;
                        }
                        console.log('waiting ' + waitMs + 'ms');
                        let startTime = Date.now();
                        while (startTime + waitMs > Date.now()) {
                            // oh my, we're busy
                        }
                    }

                    function updateProgressSync(percent) {
                        let progressResultSpan = document.querySelector('#syncProgressBarValue');
                        let progressResult = document.querySelector('#syncProgressBar');
                        console.log('work partially done ' + percent + '%');
                        progressResultSpan.textContent = percent + '%';
                        progressResult.setAttribute('value', percent);
                    }

                    document.querySelector('#buttonSyncProgressBar').addEventListener('click', function () {
                        console.log('starting work');
                        updateProgressSync(0);
                        for (let i = 1; i <= 10; i++) {
                            busyWaitMs(1000);
                            let percent = i / 10 * 100;
                            updateProgressSync(percent);
                        }
                        console.log('finished with work');
                    });
                </script>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <p>Why does this progress bar work?</p>
                <pre><code class="javascript" data-trim data-line-numbers="">
                        console.log('starting work');
                        updateProgressAsync(0);
                        let i = 1;
                        function chunkOfWork() {
                            busyWaitMs(1000);
                            updateProgressAsync(i/10*100);
                            if (++i<=10) {
                                setTimeout(chunkOfWork, 0);
                            } else {
                                console.log('finished with work');
                            }
                        }
                        setTimeout(chunkOfWork, 0);
                </code></pre>
                <div>
                    <button id="buttonAsyncProgressBar">Do A Lot Of Work</button>
                    Progress: <span id="asyncProgressBarValue">0%</span>
                    <progress id="asyncProgressBar" max="100" value="0"></progress>
                </div>
                <script>
                    // function busyWaitMs is reused from above
                    function updateProgressAsync(percent) {
                        let progressResultSpan = document.querySelector('#asyncProgressBarValue');
                        let progressResult = document.querySelector('#asyncProgressBar');
                        console.log('work partially done ' + percent + '%');
                        progressResultSpan.textContent = percent + '%';
                        progressResult.setAttribute('value', percent);
                    }

                    document.querySelector('#buttonAsyncProgressBar').addEventListener('click', function () {
                        console.log('starting work');
                        updateProgressAsync(0);
                        let i = 1;

                        function chunkOfWork() {
                            busyWaitMs(1000);
                            updateProgressAsync(i / 10 * 100);
                            if (++i <= 10) {
                                setTimeout(chunkOfWork, 0);
                            } else {
                                console.log('finished with work');
                            }
                        }

                        setTimeout(chunkOfWork, 0);
                    });
                </script>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section class="fullscreen">
            <h2>What will be the log result?</h2>
            <pre><code class="javascript" data-trim data-line-numbers="">
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
          </code></pre>
        </section>
        <section class="fullscreen">
            <h2>About <span class="cap-blue">Tasks</span></h2>
            <UL>
                <LI>Examples for tasks are setTimeout, user events, execution of loaded scripts.</LI>
                <LI>The Browser renders changes between tasks.</LI>
                <LI>Tests: tick()</LI>
            </UL>
            <pre><code data-noescape data-trim class="typescript" data-line-numbers="">
import { fakeAsync, tick } from '@angular/core/testing';

it('should set flag to true', fakeAsync(() => {
  let flag = false;
  setTimeout(() => { flag = true; });

  expect(flag).toBeFalsy();

  tick();

  expect(flag).toBeTruthy();
}));
          </code></pre>
        </section>
        <section class="fullscreen">
            <h2>About <span class="cap-blue">Microtasks</span></h2>
            <ul>
                <li>Examples: Results and errors of Promises, queueMicrotask()</li>
                <li>Microtasks are processed after tasks</li>
                <li>Tests: flushMicrotasks()</li>
            </ul>
            <pre><code data-noescape data-trim class="typescript" data-line-numbers="">
  import { fakeAsync, flushMicrotasks } from '@angular/core/testing';
  
  it('should set flag to true', fakeAsync(() => {
    let flag = false;
    Promise.resolve().then(() => { flag = true; });

    expect(flag).toBeFalsy();

    flushMicrotasks();

    expect(flag).toBeTruthy();
  }));
          </code></pre>
        </section>
        <section class="fullscreen">
          <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
button.addEventListener("click", () => {
  console.log("Listener 1");
  
  setTimeout(() => {
    console.log("SetTimeout 1");
  }, 0);
  
  Promise.resolve().then(() => {
    console.log("Promise 1");
  });  
});
button.addEventListener("click", () => {
  console.log("Listener 2");
  
  setTimeout(() => {
    console.log("SetTimeout 2");
  }, 0);

  Promise.resolve().then(() => {
    console.log("Promise 2");
  });
});
          </code></pre>
            <button id="ListenerOrderExampleButton"><h2>What's the correct order?</h2></button>
            <script type="application/javascript">
                {
                    const button = document.getElementById('ListenerOrderExampleButton');
                    button.addEventListener("click", () => {
                        console.log("Listener 1");

                        setTimeout(() => {
                            console.log("SetTimeout 1");
                        }, 0);

                        Promise.resolve().then(() => {
                            console.log("Promise 1");
                        });
                    });
                    button.addEventListener("click", () => {
                        console.log("Listener 2");

                        setTimeout(() => {
                            console.log("SetTimeout 2");
                        }, 0);

                        Promise.resolve().then(() => {
                            console.log("Promise 2");
                        });
                    });
                }
            </script>
            <aside class="notes">
                Note: addEventListener creates a macrotask for each listener when the button is clicked by the user.
                However, depending on the browser:
                When the button is clicked by code (unit test), both listeners may be executed within one macrotask thus
                resulting in a different order of output.
            </aside>
        </section>
        <section class="fullscreen">
            <p>Intermission: RxJS</p>
            <p>If you're not familiar with RxJS, now is the time to learn:
            <ul>
                <li><a href="https://devonfw-training.github.io/devon4ng-training/ng-advanced/rxjs">Angular Advanced:
                    RxJS - Levelling Up</a></li>
                <li><a href="https://rxjs.dev/">rxjs.dev</a></li>
            </ul>
            </p>
        </section>
        <section class="fullscreen">
            <p>Let's talk about async rxjs</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
const subject = new Subject&lt;boolean&gt;();

const obs = subject.asObservable();
obs.subscribe(v => console.log('next value', v));

console.log('Going to send next value');

subject.next(true);

console.log('Sent next value');
          </code></pre>
            <p>What's happening here? What's the correct order?</p>
            <aside class="notes">
                Sample code is part of the RxJs Examples repository:
                <UL>
                    <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                    <LI>start angular application</LI>
                    <LI>Tab "Training Examples"</LI>
                    <LI>Button "Timing without scheduler"</LI>
                    <LI>Code: TrainingExamplesComponent.startNoScheduler</LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>rxjs Obervable callbacks are not always microtasks!</p>
            <UL>
                <LI>Synchronous execution "when nothing else is required"</LI>
                <LI>Schedulers determine the "something else"</LI>
                <UL>
                    <LI>Microtasks when using asapScheduler</LI>
                    <LI>Macrotasks when using asyncScheduler</LI>
                </UL>
                <LI>Can be controlled with</LI>
                <UL>
                    <LI>observeOn(...)</LI>
                    <LI>subscribeOn(...)</LI>
                    <LI>Implementation of observables and operators</LI>
                </UL>
            </UL>
            <aside class="notes">
                <UL>
                    <LI>
                        https://rxjs.dev/api/operators/observeOn
                    </LI>
                    <LI>
                        https://blog.strongbrew.io/what-are-schedulers-in-rxjs/
                    </LI>
                    <LI>observeOn relates to the steps after it</LI>
                    <LI>subscribeOn to the complete execution</LI>
                    <LI>
                        Schedulers:
                        <UL>
                            <LI>Queue: As synchronously as possible</LI>
                            <LI>Asap: Microtask</LI>
                            <LI>Async: Macrotask</LI>
                            <LI>And some others, e.g. for testing or animation</LI>
                        </UL>
                    </LI>
                    <LI>
                        Some sample code is part of the RxJs Examples repository:
                        <UL>
                            <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                            <LI>start angular application</LI>
                            <LI>Tab "Training Examples"</LI>
                            <LI>Button "Scheduler comparison"</LI>
                            <LI>Code: TrainingExamplesComponent.startSchedulerComparison</LI>
                            <LI>And with a surprise: Button "Microtask vs. Promise", Code
                                TrainingExamplesComponent.startMicrotaskVsPromise
                            </LI>
                        </UL>
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
          <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
const subject = new Subject&lt;boolean&gt;();

const obs = subject.asObservable();
obs.pipe(observeOn(asyncScheduler))
   .subscribe(v => console.log('next value', v));

console.log('Going to send next value');

subject.next(true);

console.log('Sent next value');
          </code></pre>
            <p>What is happening now?</p>
            <aside class="notes">
                Sample code is part of the RxJs Examples repository:
                <UL>
                    <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                    <LI>start angular application</LI>
                    <LI>Tab "Training Examples"</LI>
                    <LI>Button "Timing with asyncScheduler"</LI>
                    <LI>Code: TrainingExamplesComponent.startAsyncScheduler</LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>What's different here?</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
this.httpClient.get('/api/books').subscribe(v => console.log('next value', v));

console.log('after');
          </code></pre>
            <p>Please explain the expected timing in this situation.</p>
            <aside class="notes">
                The important point here is: This is really asynchronous.
                The http response will come "later". And it will still be processed as a Microtask when it arrives...
            </aside>
        </section>
        <section>
            <section>
                <p>Do you know this?</p>
                <img class="no-border" src="./img/changed-after-checked-exception.png"
                     alt="Angular Exception: Changed after Checked">
                <p>Can you explain what happened?</p>
                <p>What does it have to do with microtasks / macrotasks?</p>
                <aside class="notes">
                    <UL>
                        <LI>
                            Hint: Angular change detection runs after a task when the microtask queue is empty.
                        </LI>
                        <LI>
                            https://angular.io/guide/lifecycle-hooks
                        </LI>
                        <LI>
                            Specifically:
                            https://angular.io/guide/glossary#unidirectional-data-flow
                        </LI>
                        <LI>
                            Explanation of the situation and the exception:
                            https://angular.io/errors/NG0100
                        </LI>
                        <LI>
                            Detailed explanation:
                            https://indepth.dev/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error/
                        </LI>
                        <LI>
                            Sample code is part of the RxJs Examples repository:
                            <UL>
                                <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                                <LI>start angular application</LI>
                                <LI>Tab "Change Detection Error"</LI>
                                <LI>Button "Activate Child"</LI>
                                <LI>Code: ExpressionChangedExceptionComponent</LI>
                            </UL>
                        </LI>
                    </UL>
                </aside>
            </section>
            <section>
                <h2>A few things about Angular Change Detection</h2>
                <ul>
                    <li>Why?
                        <ul>
                            <li>It's Angular's way to decide where the DOM tree has to be updated</li>
                        </ul>
                    </li>
                    <li>How?
                        <ul>
                            <li>Go through the complete component tree (yes, really!)</li>
                            <li>Simplified: Check for each component if the bindings have changed (comparing to previous
                                value)
                                or one of a few other things have happened
                            </li>
                            <li>If changed, update the DOM and/or apply to child components</li>
                        </ul>
                    </li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h2>A few things about Angular Change Detection</h2>
                <ul>
                    <li>When does this happen?
                        <ul>
                            <li>Every time an event (i.e. Macrotask) and its corresponding Microtasks has been processed
                                (implemented using zone.js)
                            </li>
                            <li>Development mode: Do it again (for the whole tree), comparing the results between the
                                passes.
                                If not equal -> Exception: rule "unidirectional data flow" violated
                            </li>
                        </ul>
                    </li>
                </ul>
                <aside class="notes">
                </aside>
            </section>
        </section>
        <section>
            <p>How to fix it? What's the better option?</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
/* Promise */
Promise.resolve().then(() => ...bad change...);

/* Timeout */
setTimeout(() => ...bad change...);

/* Change Detector */
...bad change...
this.changeDetectorRef.detectChanges();

/* asyncScheduler */
asyncScheduler.schedule(() => {
  ...bad change...;
});
            </code></pre>
            <aside class="notes">
                <UL>
                    <LI>
                        Best solution is not on the page: Avoid if possible, e.g. by moving to other lifecycle hook or
                        removing the dependency.
                    </LI>
                    <LI>
                        Detailed explanation see
                        https://indepth.dev/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error/
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
            <h2>Another problem with unit tests and async behaviour</h2>
            <ul>
                <li>ListComponent uses ListService</li>
                <li>ListService.get() returns Observable&lt;Entry[]&gt;</li>
                <li>ListComponent calls get() in ngOnInit()</li>
            </ul>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
  constructor(private service: ListService) {}

  ngOnInit(): void {
    this.service.get().subscribe(res => this.list = res);
  }
          </code></pre>
        </section>
        <section class="fullscreen">
            <h2>Basic unit test</h2>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
describe('ListComponent', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ ListComponent ],
      providers: [{
        provide: ListService,
        useValue: jasmine.createSpyObj('ListService', {
          get: of([{id: 1}])
        })
      }]
    })
  });

  it('loads list', fakeAsync(() => {
    fixture.detectChanges();
    expect(element.querySelectorAll('.list').length).toEqual(1);
  }));
});
          </code></pre>
            <p>What's wrong? Why is this not a good unit test?</p>
            <aside class="notes">
                <UL>
                    <LI>
                        Key: Async behaviour is not tested
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>To focus the problem a little further</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
ngOnInit() {
  this.loading = true;
  this.todosService.get().subscribe(todos => {
    this.todos = todos;
    this.loading = false;
  });
}
          </code></pre>
            <p>How's this code run in test and how in production?</p>
        </section>
        <section class="fullscreen">
            <p>Please explain the fix and why this small change makes all the difference</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="8,15">
describe('ListComponent', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ ListComponent ],
      providers: [{
        provide: ListService,
        useValue: jasmine.createSpyObj('ListService', {
          get: scheduled(of([{id: 1}]), asyncScheduler)
        })
      }]
    })
  });

  it('loads list', fakeAsync(() => {
    tick();
    expect(element.querySelectorAll('.list').length).toEqual(1);
  }));
});
            </code></pre>
        </section>
        <section>
            <h2>Resources</h2>
            <ul>
                <li>
                    <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">HTML Spec: Event
                        Loops</a>
                </li>
                <li>
                    <p><cite>When I told my colleague [...] I was thinking of writing a piece on microtask queueing and
                        execution within the browser's event loop, he said "I'll be honest with you Jake, I'm not going
                        to read that".</cite></p>
                    <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Deep Dive: Blog Post
                        by Chrome Dev. Expert.</a>
                </li>
            </ul>
        </section>
    </div>
</div>

<script src="./reveal.js/js/reveal.js"></script>
<script src="lib/jquery/jquery.min.js"></script>
<script src="js/js-engine.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        width: '100%',
        height: '100%',
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            {
                src: './reveal.js/lib/js/classList.js', condition: function () {
                    return !document.body.classList;
                }
            },
            {
                src: './reveal.js/plugin/markdown/marked.js', condition: function () {
                    return !!document.querySelector('[data-markdown]');
                }
            },
            {
                src: './reveal.js/plugin/markdown/markdown.js', condition: function () {
                    return !!document.querySelector('[data-markdown]');
                }
            },
            {
                src: './reveal.js/plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            },
            {src: './reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: './reveal.js/plugin/notes/notes.js', async: true}
        ]
    });
</script>
</body>
</html>
