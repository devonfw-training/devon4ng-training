<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>RxJS</title>

    <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <link rel="icon" href="./img/favicon.ico">
    <link rel="stylesheet" href="./reveal.js/css/reveal.css">
    <link rel="stylesheet" href="./reveal.js/css/theme/simple.css">
    <link rel="stylesheet" href="./css/common.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="./css/github-gist.css">
    <link rel="stylesheet" href="css/js-engine.css">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section class="fullscreen" data-background-size="80rem" data-background-position="0% 100%"
                 data-background-image="./img/Fixed_Shape_5_CapgeminiBlue_RGB.svg">
            <div class="header-bottom-left">
                <h1 class="cap-white">RxJS</h1>
                <p class="cap-white">Philip Schm√∂kel, Bernd Olleck</p>
            </div>
        </section>
        <section>
            <section>
                <h2>RxJS - Levelling Up</h2>
                <p>Documentation + Reference</p>
                <ul>
                    <li>
                        <a href="https://rxjs.dev/">rxjs.dev: Library Documentation</a>
                        <ul>
                            <li><a href="https://rxjs.dev/guide/operators">https://rxjs.dev/guide/operators</a>:
                                structured overview of operators
                            </li>
                            <li><a href="https://rxjs.dev/operator-decision-tree">https://rxjs.dev/operator-decision-tree</a>:
                                I need to do something - what can I use?
                            </li>
                        </ul>
                    </li>
                    <li>
                        From the Angular Documentation
                        <ul>
                            <li><a href="https://angular.io/guide/rx-library">https://angular.io/guide/rx-library</a> :
                                Brief introduction into some concepts
                            </li>
                            <li><a href="https://angular.io/guide/observables-in-angular">https://angular.io/guide/observables-in-angular</a>
                                : How Angular uses RxJS
                            </li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section>
                <h2>RxJS - Level 0: Basics</h2>
                <ul>
                    <li>Basic Consumption of an Observable
                        <pre><code class="javascript stretch" data-trim>
                            subscription = observable$.subscribe(
                                value => this.doSomethingWith(value));
                            ...
                            subscription.unsubscribe();

                            <span>{{ observable$ | async }}</span>
                        </code></pre>
                        Mind the memory leak - unsubscribe!
                    </li>
                    <li>Basic Creation
                        <pre><code class="javascript stretch" data-trim>
                            of( 1, 2, 3, 4 );
                            from( [ 1, 2, 3, 4 ] );

                            subject$ = new Subject();
                            subject$.next('A');
                        </code></pre>
                    </li>
                </ul>
                <aside class="notes">
                    <UL>
                        <LI>of: one parameter after another</LI>
                        <LI>from: values from the array in order, can also take iterator and promise as</LI>
                        <LI>what happens if you give an array to from? You get the complete array as a value.</LI>
                    </UL>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 0: Lifecycle</h2>
                <ul>
                    <li>Parameters of subscribe(...)</li>
                </ul>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                            observable$.subscribe(value => this.doSomethingWith(value));

                            observable$.subscribe({
                                next: value => this.doSomethingWith(value),
                                error: error => this.displayError(error),
                                complete: () => this.weAreDone()
                            });
                        </code></pre>
                <ul>
                    <li>And what happens on the source's side</li>
                </ul>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                            subject$ = new Subject();
                            subject$.next('A');
                            subject$.error('Something went wrong');
                            // or
                            subject$.complete();
                        </code></pre>
                <aside class="notes">
                    <UL>
                        <LI>Most observables do not produce values before the first subscribe (possible exception: hot
                            observables)
                        </LI>
                        <LI>Nothing after error or complete</LI>
                    </UL>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 1: Basic Operators</h2>
                <ul>
                    <li>Manipulation and side effects</li>
                </ul>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    observable$.pipe(
                        map( value => value * 2),
                        tap( value => this.doSomething(value))
                    );
                        </code></pre>
                </li>
                <ul>
                    <li>Simple selection and filtering</li>
                </ul>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // Input: 5, 3, 3, 11, 7, 7, 19
                    filter( value => value > 10)  // 11, 19
                    take( 5 )               // 5, 3, 3, 11, 7
                    distinctUntilChanged()  // 5, 3, 11, 7, 19
                        </code></pre>
                <aside class="notes">
                    <UL>
                        <LI>Hint for later (exercise level 7): distinctUntilChanged by default makes a comparison using
                            ===
                            but allows a comparator as parameter.
                        </LI>
                    </UL>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 2: Simple Combinations</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline(r): 0      1  2  3  4  5  6  7
                    // a$:                 a     a     a|
                    // b$:          b b b|
                    // c$:          c         c     c     c|
                    concat( a$, b$, c$)
                    merge( a$, b$, c$)
                </code></pre>
                <ul>
                    <li>Note: The timeline is intended relatively: timeline(r)</li>
                    <li>At the time an observable is subscribed, it starts producing values at its time 0.</li>
                    <li>I.e.: when b$ is subscribed at time 5, then it immediately delivers 3 values and completes.</li>
                    <li>And when c$ is subscribed at time 5, then it immediately delivers one value, and then delivers
                        the next one at time 7.
                    </li>
                </ul>
                <aside class="notes">
                    <ul>
                        <LI>concat: all values of the first observable, then the subscribe the second, then the third
                        </LI>
                        <li>merge: immediate subscribe, all values when they arrive</li>
                    </ul>
                    solution next page
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 2: Simple Combinations (Solution)</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline(r): 0        1  2  3  4  5         6  7  8  9  10  11
                    // a$:                   a     a     a|
                    // b$:          b b b|
                    // c$:          c           c     c            c|
                    concat( a$, b$, c$)
                    //                       a     a     a b b b c    c     c      c|
                    merge( a$, b$, c$)
                    //              b b b c  a  c  a  c  a         c|
                </code></pre>
                <aside class="notes">
                    further questions:
                    <UL>
                        <LI>What happens if b$ emits at timeslot 1?</LI>
                        <LI>What happens if b$ never completes?</LI>
                    </UL>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 3: Value Combinations</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline(r): 0         1  2  3  4  5
                    // a$:                    a1    a2    a3|
                    // b$:          b1 b2 b3|
                    // c$:          c1           c2    c3|
                    forkJoin( [a$, b$, c$])
                    combineLatest( [a$, b$, c$])
                    zip( [a$, b$, c$])
                </code></pre>
                <aside class="notes">
                    <ul>
                        <LI>forkJoin: wait until complete, then emit last values</LI>
                        <li>combineLatest: emit combinations once you have a complete set of values</li>
                        <li>zip: emit tupels of values in order</li>
                        <li>all subscribe immediately to every source</li>
                    </ul>
                    solution next page
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 3: Value Combinations (Solution)</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline(r): 0         1      2      3      4      5
                    // a$:                    a1            a2            a3|
                    // b$:          b1 b2 b3|
                    // c$:          c1               c2            c3|
                    forkJoin( [a$, b$, c$])
                    //                                                    a3b3c3|
                    combineLatest( [a$, b$, c$])
                    //                        a1b3c1 a1b3c2 a2b3c2 a2b3c3 a3b3c3|
                    zip( [a$, b$, c$])
                    //                        a1b1c1        a2b2c2        a3b3c3|
                </code></pre>
                <aside class="notes">
                    Further questions:
                    <ul>
                        <li>What happens if b$ emits at timeslot 1?</li>
                        <li>What happens if b$ never completes?</li>
                        <li>What happens if b$ only emits two values?</li>
                        <li>What is a typical usage for forkJoin? (-> do some parallel backend calls)</li>
                        <li>What is a typical usage for combineLatest? (-> something depends on two changing sources)
                        </li>
                        <li>Note: a theoretical usage of zip is parallel processing of values: One source,
                            two observable chains which do something separately but their values should be
                            combined respectively. If someone knows a real world usage, please document here...
                        </li>
                    </ul>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 4: Simple Sub Processes</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline(r):      0   1    2   3  4
                    // source:           a        b   c|
                    // inner response a:     r:a|
                    // inner response b:                 r:b|
                    // inner response c: r:c|
                    switchMap( input => getOneResponse(input))
                    concatMap( input => getOneResponse(input))
                    mergeMap( input => getOneResponse(input))
                </code></pre>
                <UL>
                    Please note the timing here:
                    <LI>the response for 'a' is returned at time +1</LI>
                    <LI>the response for 'b' is returned at time +4</LI>
                    <LI>the response for 'c' is returned immediately</LI>
                </UL>
                <aside class="notes">
                    <ul>
                        <LI>switchMap: If you get a new input, ignore the previous result if it is still pending</li>
                        <LI>concatMap: Return values for all inputs in order until inner observable completes, wait if
                            necessary
                        </li>
                        <LI>mergeMap: Return values for all inputs in order of the results</LI>
                    </ul>
                    Solution next page
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 4: Simple Sub Processes (Solution)</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline(r):      0   1    2   3  4    5  6         7
                    // source:           a        b   c|
                    // inner response a:     r:a|
                    // inner response b:                 r:b|
                    // inner response c: r:c|
                    switchMap( input => getOneResponse(input))
                    //                       r:a      r:c|
                    concatMap( input => getOneResponse(input))
                    //                       r:a                 r:b r:c|
                    mergeMap( input => getOneResponse(input))
                    //                       r:a      r:c        r:b|
                </code></pre>
                <aside class="notes">
                    Followup questions:
                    <ul>
                        <LI>What happens if the inner observable returns multiple values? -> next page</LI>
                    </ul>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 5: Complex Sub Processes</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline(r):   0  1     2    3     4   5
                    // source:        a        b          c|
                    // response a:       r:a1                 r:a2|
                    // response b:       r:b1|
                    // response c:             r:c1 r:c2|
                    switchMap( input => getResponses(input))
                    concatMap( input => getResponses(input))
                    mergeMap( input => getResponses(input))
                </code></pre>
                <aside class="notes">
                    <ul>
                        <LI>switchMap: If you get a new input, ignore the previous result if it is still pending</li>
                        <LI>concatMap: Return values for all inputs in order until inner observable completes, wait if
                            necessary
                        </li>
                        <LI>mergeMap: Return values for all inputs in order of the results</LI>
                    </ul>
                    Solution next page
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 5: Complex Sub Processes (Solution)</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline(r):   0  1     2    3     4   5     6     7     8     9
                    // source:        a        b          c|
                    // response a:       r:a1                 r:a2|
                    // response b:       r:b1|
                    // response c:             r:c1 r:c2|
                    switchMap( input => getResponses(input))
                    //                   r:a1       r:b1            r:c1  r:c2|
                    concatMap( input => getResponses(input))
                    //                   r:a1                 r:a2  r:b1        r:c1  r:c2|
                    mergeMap( input => getResponses(input))
                    //                   r:a1       r:b1      r:a2  r:c1  r:c2|
                </code></pre>
                <aside class="notes">
                    Followup questions:
                    <ul>
                        <LI>What happens if the inner observable does not return a value? (-> timeout, timeoutWith)</LI>
                        <LI>What happens if the inner observable completes late or does not complete?</LI>
                    </ul>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 6: Control Timing: Backpressure</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline (ms):   0  100  200  300  400  500  600  700  800  900  1000  1100  1200  1300  1400
                    // source:          a  b    c                        d    e         f
                    delay( 300)
                    debounceTime( 300)
                    sampleTime( 300)
                    throttleTime( 300)
                </code></pre>
                <aside class="notes">
                    <ul>
                        <li>delay: simply delay each individual value</li>
                        <li>debounceTime: wait until the value is unchanged for the given time, then emit it</li>
                        <li>sampleTime: emit the last value for each interval or none if no value was received</li>
                        <li>throttleTime: emit a value and then ignore values for the interval</li>
                    </ul>
                    Solution next page
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 6: Control Timing: Backpressure (Solution)</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // timeline (ms):   0  100  200  300  400  500  600  700  800  900  1000  1100  1200  1300
                    // source:          a  b    c                        d    e         f
                    delay( 300)
                    //                               a    b    c                        d     e           f
                    debounceTime( 300)
                    //                                         c                                          f
                    sampleTime( 300)
                    //                               c                             e                f
                    throttleTime( 300)
                    //                  a                                d              f
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 7: A bit of flow control</h2>
                iif(...): do something conditionally
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    iif( () => condition, a$, b$)
                    // condition is evaluated at subscription time
                    </code></pre>
                timeout(...): throw an error or fallback to another observable when a timeout is reached
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    timeout({ each: 1000, with: fallback$ })
                    // Timeout starts at subscription time.
                    // Once the timeout of 1000ms is triggered, only values from fallback$ are returned
                    </code></pre>
                <aside class="notes">
                    Note concerning iif: So far we do not have a convincing example where iif has to be used, most of
                    the time there is an equivalent solution with higher order observables and direct usage of 'if'
                    or '?:' which seems easier to understand.
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 8: Error handling</h2>
                catchError(...): catch errors emitted by the observable and gracefully handle them
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    source$.pipe(catchError(error => of([])))
                    // fall back to an empty array if the source observable emits an error
                    </code></pre>
                retry(number): retry the observable sequence a given number of times if an error occurs
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    source$.pipe(retry(3))
                    // Retry the observable sequence three times. Especially useful for retrying http requests
                    // Gives up after three retries and emits the original error
                    </code></pre>
                 retry(RetryConfig): retry the observable sequence based on a custom criteria
                 <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    source$
                      .pipe(
                        retry({
                            delay: (error) => {
                              if (error instanceof HttpErrorResponse && error.status === HttpStatusCode.TooManyRequests) {
                                return timer(5000);
                              }
                              return throwError(() => error);
                            },
                          })
                      )
                    // Retry the observable sequence after 5000ms if an error with code TOO_MANY_REQUESTS occurs
                    // Otherwise rethrow the error 
                     </code></pre>
                <aside class="notes">
                    Talk about observable lifecycle, how does it actually deal with errors (resubscribe), potential problems with cold observables
                    <ul>
                        <LI>catchError: Gracefully handle errors emitted by the observable sequence</li>
                        <LI>retry: Retry the observable sequence n times in case an error occurs
                        </li>
                        <LI>retry: Conditionally retry the observable sequence. Errors emitted are streamed through the errors parameter. Web
                            can access the errors and either throw or delay execution depending on the error.
                        </LI>
                    </ul>
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 8: Error Handling</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // source:          a b c x1|
                    //                  d e f x2|
                    //                  g h i x3|
                    //                  j k l x4|
                    catchError(() => of('z'))
                    retry( 2 )
                    retry({ delay: (error) => error === x1 : of(error) : throwError(() => error) })
                </code></pre>
                <ul>
                    <li>Note: xN is an error</li>
                    <li>source is a cold observable producing different values with each subscription</li>
                </ul>
                <aside class="notes">
                    Solution next page
                </aside>
            </section>
            <section>
                <h2>RxJS - Level 8: Error Handling (Solution)</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    // source:          a b c x1|
                    //                  d e f x2|
                    //                  g h i x3|
                    //                  j k l x4|
                    catchError(() => of('z'))
                    // a b c z
                    retry( 2 )
                    // a b c d e f g h i x3
                    retry({ delay: (error) => error === x1 : of(error) : throwError(() => error) })
                    // a b c d e f x2
                </code></pre>
                <aside class="notes">
                </aside>
            </section>
            <section>
                <h2>Exercise</h2>
                <ul>
                    <li><a href="https://github.com/devonfw-ng-adv-training/rxjs-exercises">Source</a></li>
                    <li>Start with branch master</li>
                    <li>
                        Check README.md for information:
                        <ul>
                            <li>Pick level or challenge to work on, 'fdescribe' the corresponding tests</li>
                            <li>Run UnitTests</li>
                            <li>Implement the features. Do not alter the tests.</li>
                        </ul>
                    </li>
                    <li>Sample solution is available on a separate branch</li>
                </ul>
            </section>
        </section>
        <section>
            <section>
                <h2>RxJS - Patterns / Examples</h2>
                <div>Some patterns and other examples:</div>
                <ul>
                    <li>Marble diagrams</li>
                    <li>takeUntil - how to elegantly unsubscribe</li>
                    <li>nested subscribes</li>
                    <li>typeahead</li>
                </ul>
            </section>
            <section>
                <h2>Please explain the marble diagram</h2>
                <div style="background-color: rgb(255, 255, 255); box-shadow: rgba(0, 0, 0, 0.17) 0px 1px 2px 1px; border-radius: 2px;">
                    <div style="padding: 10px 22px;">
                        <svg viewBox="0 0 7 10" style="width: 48px; height: 68px; overflow: visible;">
                            <line x1="0" x2="112" y1="5" y2="5" style="stroke: black; stroke-width: 0.3;"></line>
                            <polygon points="111.7,6.1 111.7,3.9 114,5"></polygon>
                        </svg>
                        <svg viewBox="0 0 100 10" style="width: 680px; height: 68px; overflow: visible;">
                            <line class="end-marker" x1="100" x2="100" y1="3.2" y2="6.8"
                                  style="stroke: black; stroke-width: 0.3; cursor: ew-resize;"></line>
                            <g class="marble" transform="translate(0, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(62, 161, 203); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    A
                                </text>
                            </g>
                            <g class="marble" transform="translate(42, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(130, 215, 54); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    B
                                </text>
                            </g>
                            <g class="marble" transform="translate(55, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(255, 105, 70); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    C
                                </text>
                            </g>
                        </svg>
                    </div>
                    <div style="padding: 10px 22px;">
                        <svg viewBox="0 0 7 10" style="width: 48px; height: 68px; overflow: visible;">
                            <line x1="0" x2="112" y1="5" y2="5" style="stroke: black; stroke-width: 0.3;"></line>
                            <polygon points="111.7,6.1 111.7,3.9 114,5"></polygon>
                        </svg>
                        <svg viewBox="0 0 100 10" style="width: 680px; height: 68px; overflow: visible;">
                            <line class="end-marker" x1="25" x2="25" y1="3.2" y2="6.8"
                                  style="stroke: black; stroke-width: 0.3; cursor: ew-resize;"></line>
                            <g class="marble" transform="translate(0, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(62, 161, 203); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    1
                                </text>
                            </g>
                            <g class="marble" transform="translate(10, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(130, 215, 54); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    2
                                </text>
                            </g>
                            <g class="marble" transform="translate(20, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(255, 203, 70); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    3
                                </text>
                            </g>
                        </svg>
                    </div>
                    <div class="operatorBox"
                         style="border: 1px solid rgba(0, 0, 0, 0.06); padding: 22px; text-align: center; position: relative;">
                        <div style="display: block; position: absolute; left: 0px; top: 0px; right: 0px; bottom: 0px; box-shadow: rgba(0, 0, 0, 0.17) 0px 2px 10px 0px;"></div>
                        <span class="operatorLabel"
                              style="font-weight: 400; font-size: 1.3rem; font-family: &quot;Source Code Pro&quot;, monospace;">obs1$.switchMap(() =&gt; obs2$, (x, y) =&gt; "" + x + y)</span>
                        <div style="display: block; position: absolute; left: 0px; top: 0px; right: 0px; bottom: 0px; box-shadow: rgba(0, 0, 0, 0.26) 0px 2px 5px 0px;"></div>
                    </div>
                    <div style="padding: 10px 22px;">
                        <svg viewBox="0 0 7 10" style="width: 48px; height: 68px; overflow: visible;">
                            <line x1="0" x2="112" y1="5" y2="5" style="stroke: black; stroke-width: 0.3;"></line>
                            <polygon points="111.7,6.1 111.7,3.9 114,5"></polygon>
                        </svg>
                        <svg viewBox="0 0 100 10" style="width: 680px; height: 68px; overflow: visible;">
                            <line class="end-marker" x1="100.01" x2="100.01" y1="3.2" y2="6.8"
                                  style="stroke: black; stroke-width: 0.3; cursor: ew-resize;"></line>
                            <g class="marble" transform="translate(0, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(62, 161, 203); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    A1
                                </text>
                            </g>
                            <g class="marble" transform="translate(10, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(130, 215, 54); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    A2
                                </text>
                            </g>
                            <g class="marble" transform="translate(20, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(255, 203, 70); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    A3
                                </text>
                            </g>
                            <g class="marble" transform="translate(42, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(255, 105, 70); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    B1
                                </text>
                            </g>
                            <g class="marble" transform="translate(52, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(62, 161, 203); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    B2
                                </text>
                            </g>
                            <g class="marble" transform="translate(55.00000000000001, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(255, 203, 70); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    C1
                                </text>
                            </g>
                            <g class="marble" transform="translate(65, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(255, 105, 70); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    C2
                                </text>
                            </g>
                            <g class="marble" transform="translate(75, 5)" style="cursor: default;">
                                <circle r="2.3" style="fill: rgb(62, 161, 203); stroke: black; stroke-width: 0.3;"></circle>
                                <text text-anchor="middle" y="0.8"
                                      style="font-size: 2.5px; font-family: &quot;Source Sans Pro&quot;, sans-serif; user-select: none;">
                                    C3
                                </text>
                            </g>
                        </svg>
                    </div>
                </div>
                <small>Taken from: https://rxmarbles.com/#switchMap</small>
            </section>
            <section>
                <h2>RxJS - Pattern: unsubscribe using takeUntil</h2>
                <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
                    class MyComponent implements OnInit, OnDestroy {
                        private onDestroy$ = new Subject();
                        ngOnInit() {
                            interval(1000).pipe(takeUntil(onDestroy$)).subscribe( () => {
                                // do something every second until the component is destroyed
                            });
                        }
                        ngOnDestroy(): void {
                            this.onDestroy$.next();
                            this.onDestroy$.complete();
                        }
                    }
                </code></pre>
                With Angular 16+ this can also be done using <a href="https://angular.io/api/core/rxjs-interop/takeUntilDestroyed">takeUntilDestroyed</a>.
                <aside class="notes">
                </aside>
            </section>
            <section class="fullscreen">
                <h2>Please explain the code</h2>
                <pre><code class="javascript" data-trim data-line-numbers="">
    ngOnInit() {
      this.todo$ = this.route.params.pipe(
        switchMap(params => this.todoService.getTodo(+params['id']))
      )
    }
          </code></pre>
                <p>... and how does it differ to the following?</p>
                <pre><code class="javascript" data-trim data-line-numbers="">
    ngOnInit() {
      this.route.params.subscribe(params => {
        this.todoService.getTodo(+params['id']).subscribe(todo => {
          this.todo = todo;
        });
      });
    }
          </code></pre>
                <p>Which version is better and why?</p>
                <aside class="notes">
                    <UL>
                        <LI>
                            Discuss: Observable chains
                        </LI>
                        <LI>
                            Discuss: Subscribe in subscribe
                        </LI>
                    </UL>
                </aside>
            </section>
            <section class="fullscreen">
                <h2>Please explain the following code</h2>
                <pre><code class="javascript stretch" data-trim data-line-numbers="">
    import { fromEvent } from 'rxjs';
    import { ajax } from 'rxjs/ajax';
    import { map, filter, debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';

    const searchInput = document.getElementById('search-box');

    const typeahead$ = fromEvent(searchInput, 'input').pipe(
      map((e: KeyboardEvent) => e.target.value),
      filter(text => text.length > 3),
      debounceTime(150),
      distinctUntilChanged(),
      switchMap(text => ajax(`/api/search?q=${text}`))
    );

    typeahead$.subscribe(data => {
      // handle search result
    });
          </code></pre>
                <p>... what does each operator do exactly? What about the order? Is it important?</p>
                <aside class="notes">
                    Some sample code (more complex) is part of the RxJs Examples repository:
                    <UL>
                        <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                        <LI>start angular application</LI>
                        <LI>Tab "Search"</LI>
                        <LI>Code: SearchComponent</LI>
                    </UL>
                </aside>
            </section>
        </section>
        <section class="fullscreen">
            <p>Let's talk about async rxjs</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
const subject = new Subject&lt;boolean&gt;();

const obs = subject.asObservable();
obs.subscribe(v => console.log('next value', v));

console.log('Going to send next value');

subject.next(true);

console.log('Sent next value');
          </code></pre>
            <p>What's happening here? What's the correct order?</p>
            <aside class="notes">
                Sample code is part of the RxJs Examples repository:
                <UL>
                    <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                    <LI>start angular application</LI>
                    <LI>Tab "Training Examples"</LI>
                    <LI>Button "Timing without scheduler"</LI>
                    <LI>Code: TrainingExamplesComponent.startNoScheduler</LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>rxjs Obervable callbacks are not always microtasks!</p>
            <UL>
                <LI>Synchronous execution "when nothing else is required"</LI>
                <LI>Schedulers determine the "something else"</LI>
                <UL>
                    <LI>Microtasks when using asapScheduler</LI>
                    <LI>Macrotasks when using asyncScheduler</LI>
                </UL>
                <LI>Can be controlled with</LI>
                <UL>
                    <LI>observeOn(...)</LI>
                    <LI>subscribeOn(...)</LI>
                    <LI>Implementation of observables and operators</LI>
                </UL>
            </UL>
            <aside class="notes">
                <UL>
                    <LI>
                        https://rxjs.dev/api/operators/observeOn
                    </LI>
                    <LI>
                        https://blog.strongbrew.io/what-are-schedulers-in-rxjs/
                    </LI>
                    <LI>observeOn relates to the steps after it</LI>
                    <LI>subscribeOn to the complete execution</LI>
                    <LI>
                        Schedulers:
                        <UL>
                            <LI>Queue: As synchronously as possible</LI>
                            <LI>Asap: Microtask</LI>
                            <LI>Async: Macrotask</LI>
                            <LI>And some others, e.g. for testing or animation</LI>
                        </UL>
                    </LI>
                    <LI>
                        Some sample code is part of the RxJs Examples repository:
                        <UL>
                            <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                            <LI>start angular application</LI>
                            <LI>Tab "Training Examples"</LI>
                            <LI>Button "Scheduler comparison"</LI>
                            <LI>Code: TrainingExamplesComponent.startSchedulerComparison</LI>
                            <LI>And with a surprise: Button "Microtask vs. Promise", Code
                                TrainingExamplesComponent.startMicrotaskVsPromise
                            </LI>
                        </UL>
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
          <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
const subject = new Subject&lt;boolean&gt;();

const obs = subject.asObservable();
obs.pipe(observeOn(asyncScheduler))
   .subscribe(v => console.log('next value', v));

console.log('Going to send next value');

subject.next(true);

console.log('Sent next value');
          </code></pre>
            <p>What is happening now?</p>
            <aside class="notes">
                Sample code is part of the RxJs Examples repository:
                <UL>
                    <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                    <LI>start angular application</LI>
                    <LI>Tab "Training Examples"</LI>
                    <LI>Button "Timing with asyncScheduler"</LI>
                    <LI>Code: TrainingExamplesComponent.startAsyncScheduler</LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>What's different here?</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
this.httpClient.get('/api/books').subscribe(v => console.log('next value', v));

console.log('after');
          </code></pre>
            <p>Please explain the expected timing in this situation.</p>
            <aside class="notes">
                The important point here is: This is really asynchronous.
                The http response will come "later". And it will still be processed as a Microtask when it arrives...
            </aside>
        </section>
        <section>
            <p>Do you know this?</p>
            <img class="no-border" src="./img/changed-after-checked-exception.png"
                 alt="Angular Exception: Changed after Checked">
            <p>Can you explain what happened?</p>
            <p>What does it have to do with microtasks / macrotasks?</p>
            <aside class="notes">
                <UL>
                    <LI>
                        Hint: Angular change detection runs after a task when the microtask queue is empty.
                    </LI>
                    <LI>
                        https://angular.io/guide/lifecycle-hooks
                    </LI>
                    <LI>
                        Specifically:
                        https://angular.io/guide/glossary#unidirectional-data-flow
                    </LI>
                    <LI>
                        Explanation of the situation and the exception:
                        https://angular.io/errors/NG0100
                    </LI>
                    <LI>
                        Detailed explanation:
                        https://indepth.dev/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error/
                    </LI>
                    <LI>
                        Sample code is part of the RxJs Examples repository:
                        <UL>
                            <LI>https://github.com/BerndOlleckCap/RxJsExamples</LI>
                            <LI>start angular application</LI>
                            <LI>Tab "Change Detection Error"</LI>
                            <LI>Button "Activate Child"</LI>
                            <LI>Code: ExpressionChangedExceptionComponent</LI>
                        </UL>
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>How to fix it? What's the better option?</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
/* Promise */
Promise.resolve().then(() => ...bad change...);

/* Timeout */
setTimeout(() => ...bad change...);

/* Change Detector */
...bad change...
this.changeDetectorRef.detectChanges();

/* asyncScheduler */
asyncScheduler.schedule(() => {
  ...bad change...;
});
            </code></pre>
            <aside class="notes">
                <UL>
                    <LI>
                        Best solution is not on the page: Avoid if possible, e.g. by moving to other lifecycle hook or
                        removing the dependency.
                    </LI>
                    <LI>
                        Detailed explanation see
                        https://indepth.dev/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error/
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
            <h2>Another problem with unit tests and async behaviour</h2>
            <ul>
                <li>ListComponent uses ListService</li>
                <li>ListService.get() returns Observable&lt;Entry[]&gt;</li>
                <li>ListComponent calls get() in ngOnInit()</li>
            </ul>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
  constructor(private service: ListService) {}

  ngOnInit(): void {
    this.service.get().subscribe(res => this.list = res);
  }
          </code></pre>
        </section>
        <section class="fullscreen">
            <h2>Basic unit test</h2>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
describe('ListComponent', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ ListComponent ],
      providers: [{
        provide: ListService,
        useValue: jasmine.createSpyObj('ListService', {
          get: of([{id: 1}])
        })
      }]
    })
  });

  it('loads list', fakeAsync(() => {
    fixture.detectChanges();
    expect(element.querySelectorAll('.list').length).toEqual(1);
  }));
});
          </code></pre>
            <p>What's wrong? Why is this not a good unit test?</p>
            <aside class="notes">
                <UL>
                    <LI>
                        Key: Async behaviour is not tested
                    </LI>
                </UL>
            </aside>
        </section>
        <section>
            <p>To focus the problem a little further</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="">
ngOnInit() {
  this.loading = true;
  this.todosService.get().subscribe(todos => {
    this.todos = todos;
    this.loading = false;
  });
}
          </code></pre>
            <p>How's this code run in test and how in production?</p>
        </section>
        <section class="fullscreen">
            <p>Please explain the fix and why this small change makes all the difference</p>
            <pre><code data-noescape data-trim class="typescript no-max-height" data-line-numbers="8,15">
describe('ListComponent', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ ListComponent ],
      providers: [{
        provide: ListService,
        useValue: jasmine.createSpyObj('ListService', {
          get: scheduled(of([{id: 1}]), asyncScheduler)
        })
      }]
    })
  });

  it('loads list', fakeAsync(() => {
    tick();
    expect(element.querySelectorAll('.list').length).toEqual(1);
  }));
});
            </code></pre>
        </section>
        <section>
            <h2>Resources</h2>
            <ul>
                <li>
                    <a href="http://reactivex.io/rxjs/manual/overview.html">RXJS Docs</a>
                </li>
                <li>
                    <a href="https://netbasal.com/testing-observables-in-angular-a2dbbfaf5329">Blog Article: Testing
                        Observables in Angular</a>
                </li>
            </ul>
        </section>
    </div>
</div>

<script src="./reveal.js/js/reveal.js"></script>
<script src="lib/jquery/jquery.min.js"></script>
<script src="js/js-engine.js"></script>

<script src="../common/reveal-config.js"></script>
<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        ...revealConfig,
        width: '100%',
        height: '100%'
    });
</script>
</body>
</html>
